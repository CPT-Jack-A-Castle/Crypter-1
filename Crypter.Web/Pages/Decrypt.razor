@page "/decrypt/message/{id:guid}"
@page "/decrypt/file/{id:guid}"

@inject IJSRuntime JsRuntime;
@inject HttpClient HttpClient
@inject NavigationManager NavManager
@inject AppSettings AppSettings

<div class="container">
    <h1>Decrypt your @dataFormat</h1>
    @if (!error)
    {
        <DecryptDetails @bind-DataFormat="dataFormat" @bind-Id="Id" @bind-Name="name" @bind-ContentType="contentType" @bind-Created="creationDate" @bind-Expiration="expirationDate" @bind-Size="fileSize"></DecryptDetails>
    } else {
        <div class="container text-center">
            <h2>@errorText</h2>
        </div>
    }
</div>

@code {
    string dataFormat = "";
    string name = "";
    string creationDate = DateTime.Now.ToString("MM/dd/yyyy");
    string expirationDate = "Never";
    int fileSize = 0;
    string contentType = "";
    private bool error = false;
    private string errorText = "";

    [Parameter]
    public Guid Id { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await JsRuntime.InvokeVoidAsync("setTitle", "Crypter - Decrypt");

        var relativeURL = NavManager.ToBaseRelativePath(NavManager.Uri);
        var urlPieces = relativeURL.Split("/");
        dataFormat = urlPieces[1].ToLower();

        if (dataFormat == "message")
        {
            var messageResponse = await DownloadMessagePreviewFromApi(Id);
            switch (messageResponse.Status)
            {
                case Contracts.Enum.ResponseCode.Success:
                    PopulateMessagePreview(messageResponse.Size, messageResponse.CreationUTC, messageResponse.ExpirationUTC);
                    break;
                default:
                    // Failed response must be handled in DownloadMessagePreview
                    break;
            }
        }
        else if (dataFormat == "file")
        {
            var fileResponse = await DownloadFilePreviewFromApi(Id);
            switch (fileResponse.Status)
            {
                case Contracts.Enum.ResponseCode.Success:
                    PopulateFilePreview(fileResponse.Name, fileResponse.Size, fileResponse.CreationUTC, fileResponse.ExpirationUTC, fileResponse.ContentType);
                    break;
                default:
                    // Failed response must be handled in DownloadFilePreview
                    break;
            }
        }
        else
        {
            // This is unnecessary. Unsupported dataFormats automatically send to the 404.
        }
    }

    private async Task<AnonymousFilePreviewResponse> DownloadFilePreviewFromApi(Guid id)
    {
        var requestBody = new AnonymousFilePreviewRequest
        {
            Id = id
        };

        var url = $"{AppSettings.ApiBaseUrl}/file/preview/{id}";
        using var response = await HttpClient.GetAsync(url);

        if (!response.IsSuccessStatusCode)
        {
            error = true;
            errorText = dataFormat + " not found";
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousFilePreviewResponse>(content);
    }

    private async Task<AnonymousMessagePreviewResponse> DownloadMessagePreviewFromApi(Guid id)
    {
        var requestBody = new AnonymousMessagePreviewRequest
        {
            Id = id
        };

        var url = $"{AppSettings.ApiBaseUrl}/message/preview/{id}";
        using var response = await HttpClient.GetAsync(url);

        if (!response.IsSuccessStatusCode)
        {
            error = true;
            errorText = dataFormat + " not found";
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousMessagePreviewResponse>(content);
    }

    private void PopulateFilePreview(string filename, int size, DateTime creation, DateTime expiration, string type)
    {
        name = filename;
        creationDate = creation.ToLocalTime().ToString();
        expirationDate = expiration.ToLocalTime().ToString();
        fileSize = size;
        contentType = type;
    }

    private void PopulateMessagePreview(int size, DateTime creation, DateTime expiration)
    {
        creationDate = creation.ToLocalTime().ToString();
        expirationDate = expiration.ToLocalTime().ToString();
        fileSize = size;
    }
}
