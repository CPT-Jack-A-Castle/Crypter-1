@page "/decrypt/message/{id:guid}"
@page "/decrypt/file/{id:guid}"

@inject IJSRuntime JsRuntime;
@inject HttpClient HttpClient
@inject NavigationManager NavManager
@inject AppSettings AppSettings
@inject IAuthenticationService AuthenticationService

@if (AuthenticationService.User != null)
{
    <NavigationUser />
}
@if (correctRecipient == true || anonymousRecipient == true)
{
    <div class="container my-4">
        <h1>Decrypt your @dataFormat</h1>
        @if (!error)
        {
            <DecryptDetails @bind-IsCorrectRecipient="correctRecipient" @bind-DataFormat="dataFormat" @bind-Id="Id" @bind-Name="name" @bind-ContentType="contentType" @bind-Created="creationDate" @bind-Expiration="expirationDate" @bind-Size="fileSize"></DecryptDetails>
        }
        else
        {
            <div class="container text-center">
                <h2>@errorText</h2>
            </div>
        }
    </div>
} else
{
    <div class="container my-4">
        <h2>This message is for a specific recipient.</h2>
        <p>If you are the intended recipient, please <a href="/login">login</a> and check your received files and messages.</p>
    </div>
}

@code {
    string dataFormat = "";
    string name = "";
    string creationDate = DateTime.Now.ToString("MM/dd/yyyy");
    string expirationDate = "Never";
    int fileSize = 0;
    string contentType = "";
    private bool error = false;
    private string errorText = "";
    private bool anonymousRecipient = false;
    private bool correctRecipient = false;

    [Parameter]
    public Guid Id { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await JsRuntime.InvokeVoidAsync("setPageTitle", "Crypter - Decrypt");

        var relativeURL = NavManager.ToBaseRelativePath(NavManager.Uri);
        var urlPieces = relativeURL.Split("/");
        dataFormat = urlPieces[1].ToLower();

        ResourceType type = dataFormat == "message"
            ? ResourceType.Message
            : ResourceType.File;

        var previewResponse = await DownloadPreviewFromApi(Id, type);
        switch (previewResponse.Status)
        {
            case Contracts.Enum.ResponseCode.Success:
                PopulatePreview(previewResponse.Name, previewResponse.Size, previewResponse.CreationUTC, previewResponse.ExpirationUTC, previewResponse.ContentType);
                if (previewResponse.Recipient == Guid.Empty)
                {
                    anonymousRecipient = true;
                }
                else if (previewResponse.Recipient.ToString() == AuthenticationService.User.Id)
                {
                    correctRecipient = true;
                }
                break;
            default:
                // Failed response must be handled in DownloadMessagePreview
                break;
        }
    }

    private async Task<AnonymousPreviewResponse> DownloadPreviewFromApi(Guid id, ResourceType type)
    {
        var requestBody = new AnonymousPreviewRequest(id, type);

        var url = $"{AppSettings.ApiBaseUrl}/anonymous/get-preview";
        using var response = await HttpClient.PostAsJsonAsync(url, requestBody);

        if (!response.IsSuccessStatusCode)
        {
            error = true;
            errorText = $"{type.ToString()} not found";
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousPreviewResponse>(content);
    }

    private void PopulatePreview(string aName, int size, DateTime creation, DateTime expiration, string aContentType)
    {
        name = aName;
        creationDate = creation.ToLocalTime().ToString();
        expirationDate = expiration.ToLocalTime().ToString();
        fileSize = size;
        contentType = aContentType;
    }
}
