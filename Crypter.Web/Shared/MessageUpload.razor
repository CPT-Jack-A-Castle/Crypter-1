@inject IJSRuntime jsRuntime
@inject HttpClient HttpClient

<div class="message-upload" hidden="@IsEncrypting">
    <div class="row">
        <div class="col-12 p-0">
            <textarea @bind="MessageText" @bind:event="oninput" id="messageText" name="messageText" rows="5" cols="57" placeholder="Type your message here..." maxlength="@MaxMessageLength"></textarea>
            <label><small class="align-text-bottom">@(MaxMessageLength - MessageText.Count()) remaining</small></label>
        </div>
    </div>
    <div class="row">
        <div class="col-12 p-0">
            <button type="button" class="btn btn-primary" @onclick="@(e => EncryptMessage(MessageText, encryptionStrength))">Encrypt</button>
        </div>
    </div>
    <UploadSuccessModal @ref="Modal" @bind-DataFormat="dataFormat" @bind-ReturnedId="returnedId" @bind-PublicKey="publicKey" @bind-PrivateKey="privateKey" />
</div>

<h3 hidden="@(!IsEncrypting)">Encryption Processing</h3>

@code {
   // Constants
   private const int MaxMessageLength = 1024;

   // User input
   private string MessageText = "";
   CryptoStrength encryptionStrength = CryptoStrength.Minimum; //TODO Allow the user to set this in the UI

   // Variables we control
   private bool IsEncrypting = false;
   private Guid returnedId;
   private string publicKey;
   private string privateKey;
   private string dataFormat;

   private async Task EncryptMessage(string message, CryptoStrength strength)
   {
      // Set is encrypting to true
      IsEncrypting = true;

      // Refer to https://stackoverflow.com/a/11701301 for procedure

      byte[] messageBytes = Encoding.UTF8.GetBytes(message);
      var clientEncryptResult = CryptoLib.Common.DoAnonymousClientEncryption(messageBytes, strength);

      // Send POST request to API with upload details
      var response = await UploadMessageToAPI(clientEncryptResult.CipherText, clientEncryptResult.Signature, clientEncryptResult.ServerEncryptionKey);

      // Send data to success modal component
      CompletedUpload(response.Id, clientEncryptResult.KeyPair.Public.ConvertToPEM(), clientEncryptResult.KeyPair.Private.ConvertToPEM());

      // Open modal
      Modal.Open();

      // Reset message text
      MessageText = "";

      // No longer encrypting
      IsEncrypting = false;
   }

   public void CompletedUpload(Guid id, string pubKey, string privKey)
   {
      dataFormat = format;
      returnedId = id;
      publicKey = pubKey;
      privateKey = privKey;
   }

   private async Task<AnonymousUploadResponse> UploadMessageToAPI(string cipherText, string signature, string serverEncryptionKey)
   {
      var postBody = new AnonymousMessageUploadRequest
      {
         CipherText = cipherText,
         Signature = signature,
         ServerEncryptionKey = serverEncryptionKey
      };
      using var response = await HttpClient.PostAsJsonAsync("https://localhost:5001/api/message", postBody);

      if (!response.IsSuccessStatusCode)
      {
         // insert error handling
      }

      var content = await response.Content.ReadAsStringAsync();
      return JsonConvert.DeserializeObject<AnonymousUploadResponse>(content);
   }

   private Crypter.Web.Shared.UploadSuccessModal Modal { get; set; }
}
