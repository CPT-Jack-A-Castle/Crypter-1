@inject IJSRuntime jsRuntime
@inject IAuthenticationService AuthenticationService
@inject IUploadService UploadService

<div class="message-upload" hidden="@IsEncrypting">
   <div class="row">
      <div class="col-12 p-0 my-3">
         <input type="text" class="form-control" @bind="MessageSubject" @bind:event="oninput" id="messageSubject" name="messageSubject" placeholder="Subject">
      </div>
      <div class="col-12 p-0">
         <textarea class="form-control" @bind="MessageText" @bind:event="oninput" id="messageText" name="messageText" rows="5" cols="57" placeholder="Type your message here..." maxlength="@MaxMessageLength"></textarea>
         <label><small class="align-text-bottom">@(MaxMessageLength - MessageText.Count()) remaining</small></label>
      </div>
   </div>
   <div class="row">
      @if (Error)
      {
         <div class="validation-errors my-3">
            <div class="alert alert-danger" role="alert">
               @ErrorMessage
            </div>
         </div>
      }
   </div>
   <div class="row">
      <div class="col-12 p-0">
         <button type="button" class="btn btn-primary mx-auto d-block" @onclick="@(e => OnEncryptClicked(MessageText, encryptionStrength))">Encrypt</button>
      </div>
   </div>
   <UploadSuccessModal @ref="Modal" @bind-DataFormat="dataFormat" @bind-ReturnedId="returnedId" @bind-PrivateKey="privateKey" />
   <UploadSuccessModalWithRecipient @ref="ModalForRecipient" />
</div>

<div class="encrypt-status" hidden="@(!IsEncrypting)">
   <h3>@EncryptionStatusMessage</h3>
   <div class="spinner-border" role="status">
      <span class="visually-hidden">Loading...</span>
   </div>
</div>

@code {
   [Parameter]
   public string RecipientUsername { get; set; }

   [Parameter]
   public string RecipientPublicKey { get; set; }

   // Constants
   private const int MaxMessageLength = 1024;

   // State
   private bool IsEncrypting = false;
   private string EncryptionStatusMessage = "";
   private bool Error = false;
   private string ErrorMessage = "";

   // User input
   private string MessageText = "";
   private string MessageSubject = "";
   CryptoStrength encryptionStrength = CryptoStrength.Minimum;

   // Variables we control
   private Guid returnedId;
   private string privateKey;
   private string dataFormat;

   // Generated keys and crypto params
   private WrapsAsymmetricCipherKeyPair asymmetricKeyPair;
   private SymmetricCryptoParams symmetricParams;
   private byte[] serverEncryptionKey;

   private async Task OnEncryptClicked(string message, CryptoStrength strength)
   {
      IsEncrypting = true;
      await GenerateKeys(strength);
      GC.Collect();
      await EncryptMessage(message, strength);
      GC.Collect();
      ClearKeys();
      GC.Collect();
   }

   private async Task GenerateKeys(CryptoStrength strength)
   {
      await SetNewEncryptionStatus("Creating symmetric key");
      symmetricParams = CryptoLib.Common.GenerateSymmetricCryptoParams(strength);
      serverEncryptionKey = CryptoLib.Common.GetDigest(symmetricParams.Key.ConvertToBytes(), DigestAlgorithm.SHA256);

      await SetNewEncryptionStatus("Creating asymmetric keys. This may take a while.");
      asymmetricKeyPair = CryptoLib.Common.GenerateAsymmetricKeys(strength);
   }

   private void ClearKeys()
   {
      asymmetricKeyPair = null;
      symmetricParams = null;
      serverEncryptionKey = null;
   }

   private async Task EncryptMessage(string message, CryptoStrength strength)
   {
      await SetNewEncryptionStatus("Encrypting your message");
      byte[] messageBytes = Encoding.UTF8.GetBytes(message);
      var cipherText = CryptoLib.Common.DoSymmetricEncryption(messageBytes, symmetricParams);

      await SetNewEncryptionStatus("Encrypting symmetric key");
      var publicKeyToEncryptWith = string.IsNullOrEmpty(RecipientUsername)
          ? asymmetricKeyPair.Public
          : CryptoLib.Common.ConvertRsaPublicKeyFromPEM(RecipientPublicKey);

      var encryptedSymmetricInfo = CryptoLib.Common.EncryptSymmetricInfo(symmetricParams, publicKeyToEncryptWith);

      await SetNewEncryptionStatus("Creating a signature");
      var signature = CryptoLib.Common.SignPlaintext(messageBytes, asymmetricKeyPair.Private);

      await SetNewEncryptionStatus("Preparing to upload");
      var encodedCipherText = Convert.ToBase64String(cipherText);
      var encodedSymmetricInfo = Convert.ToBase64String(encryptedSymmetricInfo);
      var encodedServerEncryptionKey = Convert.ToBase64String(serverEncryptionKey);
      var encodedSignature = Convert.ToBase64String(signature);
      var encodedPublicKey = Convert.ToBase64String(
          Encoding.UTF8.GetBytes(asymmetricKeyPair.Public.ConvertToPEM()));

      await SetNewEncryptionStatus("Uploading");
      var withAuth = AuthenticationService.User is not null;

      // TODO - Need to sign with the user's private key; not the generated private key
      var request = new MessageUploadRequest(MessageSubject, encodedCipherText, encodedSymmetricInfo, encodedSignature, encodedServerEncryptionKey, encodedPublicKey, RecipientUsername);
      var (_, response) = await UploadService.UploadMessageAsync(request, withAuth);
      switch (response.Result)
      {
         case UploadResult.BlockedByUserPrivacy:
            Error = true;
            ErrorMessage = "This user does not accept messages.";
            IsEncrypting = false;
            return;
         case UploadResult.OutOfSpace:
            Error = true;
            ErrorMessage = "The server is full.  Try again later.";
            IsEncrypting = false;
            return;
         default:
            break;
      }

      CompletedUpload(response.Id, Convert.ToBase64String(Encoding.UTF8.GetBytes(asymmetricKeyPair.Private.ConvertToPEM())));

      if (string.IsNullOrEmpty(RecipientUsername))
      {
         Modal.Open();
      }
      else
      {
         ModalForRecipient.Open();
      }

      MessageSubject = "";
      MessageText = "";
      IsEncrypting = false;
   }

   public async Task SetNewEncryptionStatus(string status)
   {
      EncryptionStatusMessage = status;
      StateHasChanged();
      await Task.Delay(500);
   }

   public void CompletedUpload(Guid id, string privKey)
   {
      dataFormat = "message";
      returnedId = id;
      privateKey = privKey;
   }

   private Crypter.Web.Shared.UploadSuccessModal Modal { get; set; }
   private Crypter.Web.Shared.UploadSuccessModalWithRecipient ModalForRecipient { get; set; }

   [Parameter]
   public EventCallback<string> RecipientUsernameChanged { get; set; }

   [Parameter]
   public EventCallback<string> RecipientPublicKeyChanged { get; set; }
}
