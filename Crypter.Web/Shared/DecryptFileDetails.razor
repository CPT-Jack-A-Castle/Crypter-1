@inject IJSRuntime js
@inject IAuthenticationService AuthenticationService
@inject IDownloadService DownloadService;

<div class="row">
   <div class="col-md-4">
      <div class="card">
         <h5 class="card-header">Details</h5>
         <ul class="list-group list-group-flush">
            <li class="list-group-item"><span class="fw-bold">File name: </span>@FileName</li>
            <li class="list-group-item">
               <span class="fw-bold">Sender: </span>
               @if (SenderId == Guid.Empty)
               {
                  <span>Unknown</span>
               }
               else
               {
                  <a href=@($"/user/profile/{SenderUsername}")>@($"@{SenderUsername}")</a>
               }
            </li>
            <li class="list-group-item"><span class="fw-bold">Type: </span>@ContentType</li>
            <li class="list-group-item"><span class="fw-bold">Size: </span>@Size bytes</li>
            <li class="list-group-item"><span class="fw-bold">Created: </span>@Created</li>
            <li class="list-group-item"><span class="fw-bold">Expiration: </span>@Expiration</li>
         </ul>
      </div>
   </div>
   <div class="col-md-8">
      <div class="card">
         <div class="card-body text-center">
            @if (DecryptionSuccess == false)
            {
               <h5 class="card-title">Decryption Key</h5>
               @if (UserIsRecipient)
               {
                  <p class="card-text fst-italic">This file was sent directly to you and encrypted using your public key. Decryption will occur with your private key.</p>
               }
               else
               {
                  <p class="card-text fst-italic">This should have been provided by the sender</p>
               }
               @if (DecryptionError == true)
               {
                  <div class="alert alert-danger text-center" role="alert">
                     @DecryptionErrorText
                  </div>
               }
               @if (!IsDecrypting)
               {
                  <div class="mb-3">
                     <input type="text" class="form-control" id="decryptionKey" @bind="DecryptionKey">
                  </div>
                  <div class="mb-3">
                     <button type="button" class="btn btn-primary" @onclick="@(e => OnDecryptClicked(Id, DecryptionKey, false))">Decrypt your file</button>
                  </div>
               }
               else
               {
                  <div class="mb-3">
                     <h3>@DecryptionStatusMessage</h3>
                     <div class="spinner-border" role="status">
                        <span class="visually-hidden">Loading...</span>
                     </div>
                  </div>
               }
            }
            else
            {
               <div class="alert alert-success text-center" role="alert">
                  Decryption successful!
               </div>
               <div class="mb-3">
                  <button type="button" class="btn btn-primary" @onclick="@(e => DownloadFile(FileName, DecryptedFile, ContentType))">Download your file</button>
               </div>
            }
         </div>
      </div>
   </div>
</div>

@code {
   [Parameter]
   public Guid Id { get; set; }

   [Parameter]
   public string FileName { get; set; }

   [Parameter]
   public string ContentType { get; set; }

   [Parameter]
   public Guid SenderId { get; set; }

   [Parameter]
   public string SenderUsername { get; set; }

   [Parameter]
   public string SenderPublicAlias { get; set; }

   [Parameter]
   public Guid RecipientId { get; set; }

   [Parameter]
   public string Created { get; set; }

   [Parameter]
   public int Size { get; set; }

   [Parameter]
   public string Expiration { get; set; }

   private bool UserIsRecipient;
   private bool IsDecrypting;
   private string DecryptionStatusMessage;
   private string DecryptionKey;
   private bool DecryptionSuccess;
   private bool DecryptionError;
   private string DecryptionErrorText;
   private byte[] DecryptedFile;

   [Inject] public IBlazorDownloadFileService BlazorDownloadFileService { get; set; }

   protected override async Task OnInitializedAsync()
   {
      UserIsRecipient = RecipientId == AuthenticationService.User?.Id;
      if (UserIsRecipient)
      {
         UserIsRecipient = true;
         await OnDecryptClicked(Id, AuthenticationService.User.PrivateKey, true);
      }
   }

   private async Task OnDecryptClicked(Guid id, string privateKey, bool privateKeyAlreadyDecoded)
   {
      IsDecrypting = true;
      DecryptionError = false;

      string privatePemKey;
      if (privateKeyAlreadyDecoded)
      {
         privatePemKey = privateKey;
      }
      else
      {
         // Attempt to convert the decryption key from Base64
         await SetNewDecryptionStatus("Decoding key");
         try
         {
            byte[] pemKeyAsBytes = Convert.FromBase64String(privateKey);
            privatePemKey = Encoding.UTF8.GetString(pemKeyAsBytes);
         }
         catch (FormatException)
         {
            DecryptionError = true;
            IsDecrypting = false;
            DecryptionErrorText = "Invalid key format";
            return;
         }
      }

      await SetNewDecryptionStatus("Downloading signature and encrypted symmetric details");
      var makeRequestsWithAuth = AuthenticationService.User is not null;
      var signatureRequest = new GenericSignatureRequest(id);
      var (_, signatureResponse) = await DownloadService.DownloadFileSignatureAsync(signatureRequest, makeRequestsWithAuth);
      byte[] signature = Convert.FromBase64String(signatureResponse.SignatureBase64);
      byte[] encryptedSymmetricInfo = Convert.FromBase64String(signatureResponse.EncryptedSymmetricInfoBase64);
      string publicPemKey = Encoding.UTF8.GetString(Convert.FromBase64String(signatureResponse.PublicKeyBase64));

      // Attempt to decrypt the signature using the provided key
      await SetNewDecryptionStatus("Decrypting symmetric details");
      SymmetricInfoDTO symmetricInfo;
      try
      {
         symmetricInfo = CryptoLib.Common.DecryptAndDeserializeSymmetricInfo(encryptedSymmetricInfo, privatePemKey);
      }
      catch (FormatException)
      {
         DecryptionError = true;
         IsDecrypting = false;
         DecryptionErrorText = "Failed to decrypt symmetric details";
         return;
      }

      // Request the ciphertext from the server
      await SetNewDecryptionStatus("Downloading file");
      var serverDecryptionKey = CryptoLib.Common.GetDigest(symmetricInfo.Key, DigestAlgorithm.SHA256);
      var encodedServerDecryptionKey = Convert.ToBase64String(serverDecryptionKey);
      var ciphertextRequest = new GenericCiphertextRequest(id, encodedServerDecryptionKey);
      var (_, ciphertextResponse) = await DownloadService.DownloadFileCiphertextAsync(ciphertextRequest, makeRequestsWithAuth);

      // Error handler
      switch (ciphertextResponse.Result)
      {
         case DownloadCiphertextResult.Success:
            break;
         case DownloadCiphertextResult.NotFound:
            DecryptionErrorText = "Message not found";
            DecryptionError = true;
            IsDecrypting = false;
            return;
         case DownloadCiphertextResult.ServerDecryptionFailed:
            DecryptionErrorText = "Failed to remove server-side encryption";
            DecryptionError = true;
            IsDecrypting = false;
            return;
         default:
            DecryptionError = true;
            IsDecrypting = false;
            return;
      }

      // Decrypt the ciphertext using the symmetric key from the signature
      await SetNewDecryptionStatus($"Decrypting file");
      byte[] ciphertextBytes = Convert.FromBase64String(ciphertextResponse.CipherTextBase64);
      var symmetricParams = CryptoLib.Common.MakeSymmetricCryptoParams(symmetricInfo.Key, symmetricInfo.IV);
      byte[] plaintextBytes = CryptoLib.Common.UndoSymmetricEncryption(ciphertextBytes, symmetricParams);

      await SetNewDecryptionStatus("Verifying decrypted file");
      DecryptionSuccess = CryptoLib.Common.VerifySignature(plaintextBytes, signature, publicPemKey);

      if (DecryptionSuccess)
      {
         DecryptedFile = plaintextBytes;
      }
      else
      {
         DecryptionError = true;
         IsDecrypting = false;
         DecryptionErrorText = "Failed to verify decrypted file";
      }
   }

   private async Task DownloadFile(string fileName, byte[] fileContent, string contentType)
   {
      await BlazorDownloadFileService.DownloadFileAsync(fileName, fileContent, contentType);
   }

   public async Task SetNewDecryptionStatus(string status)
   {
      DecryptionStatusMessage = status;
      StateHasChanged();
      await Task.Delay(500);
   }

   [Parameter]
   public EventCallback<Guid> IdChanged { get; set; }

   [Parameter]
   public EventCallback<string> FileNameChanged { get; set; }

   [Parameter]
   public EventCallback<string> ContentTypeChanged { get; set; }

   [Parameter]
   public EventCallback<Guid> SenderIdChanged { get; set; }

   [Parameter]
   public EventCallback<string> SenderUsernameChanged { get; set; }

   [Parameter]
   public EventCallback<string> SenderPublicAliasChanged { get; set; }

   [Parameter]
   public EventCallback<Guid> RecipientIdChanged { get; set; }

   [Parameter]
   public EventCallback<string> CreatedChanged { get; set; }

   [Parameter]
   public EventCallback<int> SizeChanged { get; set; }

   [Parameter]
   public EventCallback<string> ExpirationChanged { get; set; }
}
