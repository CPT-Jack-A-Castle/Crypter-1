@inject AppSettings AppSettings
@inject IJSRuntime js
@inject IHttpService HttpService
@inject IAuthenticationService AuthenticationService

<div class="row">
    <div class="col-md-4">
        <div class="card">
            <h5 class="card-header">Details</h5>
            <ul class="list-group list-group-flush">
                @if (DataFormat.ToLower() == "file")
                {
                    <li class="list-group-item"><span class="fw-bold">File name: </span>@Name</li>
                    <li class="list-group-item"><span class="fw-bold">Type: </span>@ContentType</li>
                }
                else
                {
                    <li class="list-group-item"><span class="fw-bold">Subject: </span>@Name</li>
                }
                <li class="list-group-item"><span class="fw-bold">Created: </span>@Created</li>
                <li class="list-group-item"><span class="fw-bold">Expires: </span>@Expiration</li>
                <li class="list-group-item"><span class="fw-bold">Size: </span>@Size bytes</li>
            </ul>
        </div>
    </div>
    <div class="col-md-8">
        <div class="card">
            <div class="card-body text-center">
                @if (decryptionSuccess == false)
                {
                    <h5 class="card-title">Decryption Key</h5>
                    <p class="card-text fst-italic">This should have been provided by the sender</p>
                    @if (decryptionError == true)
                    {
                        <div class="alert alert-danger text-center" role="alert">
                            @decryptionErrorText
                        </div>
                    }
                    @if (!IsDecrypting)
                    {
                        <div class="mb-3">
                            <input type="text" class="form-control" id="decryptionKey" @bind="decryptionKey">
                        </div>
                        <div class="mb-3">
                            <button type="button" class="btn btn-primary" @onclick="@(e => OnDecryptClicked(DataFormat, Id, decryptionKey, false))">Decrypt your @DataFormat</button>
                        </div>
                    }
                    else
                    {
                        <div class="mb-3">
                            <h3>@DecryptionStatusMessage</h3>
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    }
                }
                else
                {
                    <div class="alert alert-success text-center" role="alert">
                        Decryption successful!
                    </div>
                    @if (DataFormat == "message")
                    {
                        <div class="mb-3">
                            <textarea @bind="decryptedMessage" class="form-control" rows="5"></textarea>
                        </div>
                    }
                    else
                    {
                        <div class="mb-3">
                            <button type="button" class="btn btn-primary" @onclick="@(e => DownloadFile(Name, decryptedFile, ContentType))">Download your file</button>
                        </div>
                    }
                }
            </div>
        </div>
    </div>
</div>

@code {

    // State
    private bool IsDecrypting = false;
    private string DecryptionStatusMessage = "";

    private string decryptionKey = "";
    private bool decryptionSuccess = false;
    private bool decryptionError = false;
    private string decryptionErrorText = "";
    private string decryptedMessage = "";
    private byte[] decryptedFile;

    [Inject] public IBlazorDownloadFileService BlazorDownloadFileService { get; set; }

    // Stores the Format received by parent component
    [Parameter] public string DataFormat { get; set; }

    // Stores the ID received by parent component
    [Parameter] public Guid Id { get; set; }

    // Stores the File name received by parent component
    [Parameter] public string Name { get; set; }

    // Stores the Creation Date received by parent component
    [Parameter] public string Created { get; set; }

    // Stores the Size received by parent component
    [Parameter] public int Size { get; set; }

    // Stores the Expiration Date received by parent component
    [Parameter] public string Expiration { get; set; }

    // Store the Content Type received by parent component
    [Parameter] public string ContentType { get; set; }

    // Is for a specific recipient
    [Parameter] public bool IsCorrectRecipient { get; set; }

    // Watch for changes in variable values in parent component to update here
    [Parameter] public EventCallback<string> DataFormatChanged { get; set; }
    [Parameter] public EventCallback<Guid> IdChanged { get; set; }
    [Parameter] public EventCallback<string> NameChanged { get; set; }
    [Parameter] public EventCallback<string> CreatedChanged { get; set; }
    [Parameter] public EventCallback<int> SizeChanged { get; set; }
    [Parameter] public EventCallback<string> ExpirationChanged { get; set; }
    [Parameter] public EventCallback<string> ContentTypeChanged { get; set; }
    [Parameter] public EventCallback<bool> IsCorrectRecipientChanged { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (IsCorrectRecipient)
        {
            await OnDecryptClicked(DataFormat, Id, AuthenticationService.User.PrivateKey, true);
        }
    }

    private async Task OnDecryptClicked(string dataFormat, Guid id, string privateKey, bool privateKeyAlreadyDecoded)
    {
        IsDecrypting = true;
        decryptionError = false;

        string privatePemKey;
        if (privateKeyAlreadyDecoded)
        {
            privatePemKey = privateKey;
        }
        else
        {
            // Attempt to convert the decryption key from Base64
            await SetNewDecryptionStatus("Decoding key");
            try
            {
                byte[] pemKeyAsBytes = Convert.FromBase64String(privateKey);
                privatePemKey = Encoding.UTF8.GetString(pemKeyAsBytes);
            }
            catch (FormatException)
            {
                decryptionError = true;
                IsDecrypting = false;
                decryptionErrorText = "Invalid key format";
                return;
            }
        }

        ResourceType resourceType = DataFormat.ToLower() == "message"
            ? ResourceType.Message
            : ResourceType.File;

        await SetNewDecryptionStatus("Downloading signature and encrypted symmetric details");
        var signatureResponse = await DownloadSignature(resourceType, id);
        byte[] signature = Convert.FromBase64String(signatureResponse.Signature);
        byte[] encryptedSymmetricInfo = Convert.FromBase64String(signatureResponse.EncryptedSymmetricInfo);
        string publicPemKey = Encoding.UTF8.GetString(Convert.FromBase64String(signatureResponse.PublicKey));

        // Attempt to decrypt the signature using the provided key
        await SetNewDecryptionStatus("Decrypting symmetric details");
        SymmetricInfoDTO symmetricInfo;
        try
        {
            symmetricInfo = CryptoLib.Common.DecryptAndDeserializeSymmetricInfo(encryptedSymmetricInfo, privatePemKey);
        }
        catch (FormatException)
        {
            decryptionError = true;
            IsDecrypting = false;
            decryptionErrorText = "Failed to decrypt symmetric details";
            return;
        }

        // Request the ciphertext from the server
        await SetNewDecryptionStatus($"Downloading {dataFormat}");
        var serverDecryptionKey = CryptoLib.Common.GetDigest(symmetricInfo.Key, DigestAlgorithm.SHA256);
        var encodedServerDecryptionKey = Convert.ToBase64String(serverDecryptionKey);
        var ciphertextResponse = await DownloadCiphertext(resourceType, id, encodedServerDecryptionKey);

        // Error handler
        switch (ciphertextResponse.Status)
        {
            case ResponseCode.Success:
                break;
            case ResponseCode.DecryptFailure:
                decryptionErrorText = "Failed to remove server-side encryption";
                decryptionError = true;
                IsDecrypting = false;
                return;
            case ResponseCode.DigestsDoNotMatch:
                decryptionErrorText = "Wrong symmetric key provided to API";
                decryptionError = true;
                IsDecrypting = false;
                return;
            default:
                decryptionError = true;
                IsDecrypting = false;
                return;
        }

        // Decrypt the ciphertext using the symmetric key from the signature
        await SetNewDecryptionStatus($"Decrypting {dataFormat}");
        byte[] ciphertextBytes = Convert.FromBase64String(ciphertextResponse.CipherText);
        var symmetricParams = CryptoLib.Common.MakeSymmetricCryptoParams(symmetricInfo.Key, symmetricInfo.IV);
        byte[] plaintextBytes = CryptoLib.Common.UndoSymmetricEncryption(ciphertextBytes, symmetricParams);

        await SetNewDecryptionStatus($"Verifying decrypted {dataFormat}");
        decryptionSuccess = CryptoLib.Common.VerifySignature(plaintextBytes, signature, publicPemKey);

        if (decryptionSuccess)
        {
            if (dataFormat == "message")
            {
                decryptedMessage = Encoding.UTF8.GetString(plaintextBytes);
            }
            else
            {
                decryptedFile = plaintextBytes;
            }
        }
        else
        {
            decryptionError = true;
            IsDecrypting = false;
            decryptionErrorText = $"Failed to verify decrypted {dataFormat.ToLower()}";
            return;
        }
    }

    /// <summary>
    /// Request the signature from the API
    /// </summary>
    /// <param name="dataFormat">"file" or "message"</param>
    /// <param name="id">The guid corresponding to the resource</param>
    /// <returns></returns>
    private async Task<AnonymousSignatureResponse> DownloadSignature(ResourceType type, Guid id)
    {
        var url = $"{AppSettings.ApiBaseUrl}/anonymous/get-signature";
        var requestBody = new AnonymousSignatureRequest(id, type);
        return await HttpService.Post<AnonymousSignatureResponse>(url, requestBody);
    }

    /// <summary>
    /// Request the ciphertext from
    /// </summary>
    /// <param name="dataFormat">"file" or "message"</param>
    /// <param name="id">The guid corresponding to the resource</param>
    /// <param name="serverDecryptionKey">Base64(Sha256(GetBytes(symmetricKey)))</param>
    /// <returns></returns>
    private async Task<AnonymousDownloadResponse> DownloadCiphertext(ResourceType type, Guid id, string serverDecryptionKey)
    {
        var url = $"{AppSettings.ApiBaseUrl}/anonymous/get-item";
        var requestBody = new AnonymousDownloadRequest(id, type, serverDecryptionKey);
        return await HttpService.Post<AnonymousDownloadResponse>(url, requestBody);
    }

    private async Task DownloadFile(string fileName, byte[] fileContent, string contentType)
    {
        await BlazorDownloadFileService.DownloadFileAsync(fileName, fileContent, contentType);
    }

    public async Task SetNewDecryptionStatus(string status)
    {
        DecryptionStatusMessage = status;
        StateHasChanged();
        await Task.Delay(500);
    }
}
