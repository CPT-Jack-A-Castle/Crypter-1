@inject HttpClient HttpClient
@inject AppSettings AppSettings
@inject IJSRuntime js

<div class="row">
    <div class="col-md-4">
        <div class="card">
            <h5 class="card-header">@DataFormat Details</h5>
            <ul class="list-group list-group-flush">
                @if (DataFormat.ToLower() == "file")
                {
                    <li class="list-group-item"><span class="fw-bold">File name: </span>@Name</li>
                }
                <li class="list-group-item"><span class="fw-bold">Created: </span>@Created</li>
                <li class="list-group-item"><span class="fw-bold">Expires: </span>@Expiration</li>
                <li class="list-group-item"><span class="fw-bold">Size: </span>@Size bytes</li>
            </ul>
        </div>
    </div>
    <div class="col-md-8">
        <div class="card">
            <div class="card-body text-center">
                @if (decryptionSuccess == false)
                {
                    <h5 class="card-title">Decryption Key</h5>
                    <p class="card-text fst-italic">This should have been provided by the sender</p>
                    <div class="mb-3">
                        <input type="text" class="form-control" id="decryptionKey" @bind="decryptionKey">
                    </div>
                    <div class="mb-3">
                        <button type="button" class="btn btn-primary" @onclick="@(e => OnDecryptClicked(DataFormat, Id, decryptionKey))">Decrypt your @DataFormat</button>
                    </div>
                }
                else
                {
                    <div class="alert alert-success text-center" role="alert">
                        Decryption successful!
                    </div>
                    @if (DataFormat == "message")
                    {
                        <div class="mb-3">
                            <textarea @bind="decryptedMessage" class="form-control" rows="5"></textarea>
                        </div>
                    } else
                    {
                        <div class="mb-3">
                            <button type="button" class="btn btn-primary" @onclick="@(e => DownloadFile(Name, decryptedFile))">Download your file</button>
                        </div>
                    }
                }
            </div>
        </div>
    </div>
</div>

@code {
    private string decryptionKey = "";
    private bool decryptionSuccess = false;
    private string decryptedMessage = "";
    private byte[] decryptedFile;

    // Stores the Format received by parent component
    [Parameter] public string DataFormat { get; set; }

    // Stores the ID received by parent component
    [Parameter] public Guid Id { get; set; }

    // Stores the File name received by parent component
    [Parameter] public string Name { get; set; }

    // Stores the Creation Date received by parent component
    [Parameter] public string Created { get; set; }

    // Stores the Size received by parent component
    [Parameter] public int Size { get; set; }

    // Stores the Expiration Date received by parent component
    [Parameter] public string Expiration { get; set; }

    // Watch for changes in variable values in parent component to update here
    [Parameter] public EventCallback<string> DataFormatChanged { get; set; }
    [Parameter] public EventCallback<Guid> IdChanged { get; set; }
    [Parameter] public EventCallback<string> NameChanged { get; set; }
    [Parameter] public EventCallback<string> CreatedChanged { get; set; }
    [Parameter] public EventCallback<int> SizeChanged { get; set; }
    [Parameter] public EventCallback<string> ExpirationChanged { get; set; }

    private async Task OnDecryptClicked(string dataFormat, Guid id, string privateDecryptionKey)
    {
        // Attempt to convert the decryption key from Base64
        string pemKey;
        try
        {
            byte[] pemKeyAsBytes = Convert.FromBase64String(privateDecryptionKey);
            pemKey = Encoding.UTF8.GetString(pemKeyAsBytes);
        }
        catch (FormatException)
        {
            Console.WriteLine("Invalid key format");  // Todo
            return;
        }

        // Request the signature from the API
        var signatureResponse = await DownloadSignature(dataFormat, id);
        byte[] encryptedSignature = Convert.FromBase64String(signatureResponse.Signature);

        // Attempt to decrypt the signature using the provided key
        AnonymousSignature signature = CryptoLib.Common.DecryptAndDeserializeSignature(encryptedSignature, pemKey);

        // Request the ciphertext from the server
        var serverDecryptionKey = DigestMethods.GetDigest(signature.Key, DigestAlgorithm.SHA256);
        var encodedServerDecryptionKey = Convert.ToBase64String(serverDecryptionKey);
        var ciphertextResponse = await DownloadCiphertext(DataFormat, id, encodedServerDecryptionKey);

        // Decrypt the ciphertext using the symmetric key from the signature
        byte[] ciphertextBytes = Convert.FromBase64String(ciphertextResponse.CipherText);
        var symmetricParams = CryptoLib.Common.MakeSymmetricCryptoParams(signature.Key, signature.IV);
        byte[] plaintextBytes = CryptoLib.Common.UndoSymmetricEncryption(ciphertextBytes, symmetricParams);

        var verifyResult = CryptoLib.Common.VerifyPlaintextAgainstKnownDigest(plaintextBytes, signature.Digest);
        if (verifyResult)
        {
            Console.WriteLine("Plaintext looks good!");
            decryptionSuccess = true;
        }
        else
        {
            Console.WriteLine("Plaintext is bad :(");
        }

        if (dataFormat == "message")
        {
            decryptedMessage = Encoding.UTF8.GetString(plaintextBytes);
        }
        else
        {
            decryptedFile = plaintextBytes;
            // Probably this: https://stackoverflow.com/a/53822526
        }
    }

    /// <summary>
    /// Request the signature from the API
    /// </summary>
    /// <param name="dataFormat">"file" or "message"</param>
    /// <param name="id">The guid corresponding to the resource</param>
    /// <returns></returns>
    private async Task<AnonymousSignatureResponse> DownloadSignature(string dataFormat, Guid id)
    {
        var url = $"{AppSettings.ApiBaseUrl}/{dataFormat}/signature/{id}";
        using var response = await HttpClient.GetAsync(url);

        if (!response.IsSuccessStatusCode)
        {
            // insert error handling
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousSignatureResponse>(content);
    }

    /// <summary>
    /// Request the ciphertext from the API
    /// </summary>
    /// <param name="dataFormat">"file" or "message"</param>
    /// <param name="id">The guid corresponding to the resource</param>
    /// <param name="serverDecryptionKey">Base64(Sha256(GetBytes(symmetricKey)))</param>
    /// <returns></returns>
    private async Task<AnonymousDownloadResponse> DownloadCiphertext(string dataFormat, Guid id, string serverDecryptionKey)
    {
        var fileRequestBody = new AnonymousFileDownloadRequest
        {
            Id = id,
            ServerDecryptionKey = serverDecryptionKey
        };

        var messageRequestBody = new AnonymousMessageDownloadRequest
        {
            Id = id,
            ServerDecryptionKey = serverDecryptionKey
        };

        var url = $"{AppSettings.ApiBaseUrl}/{dataFormat}/actual";

        using var response = dataFormat == "file"
            ? await HttpClient.PostAsJsonAsync(url, fileRequestBody)
            : await HttpClient.PostAsJsonAsync(url, messageRequestBody);

        if (!response.IsSuccessStatusCode)
        {
            // insert error handling
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousDownloadResponse>(content);
    }

    private void DownloadFile(string fileName, byte[] fileContent)
    {
        FileUtil.SaveAs(js, fileName, fileContent);
    }
}
