@inject HttpClient HttpClient
@inject AppSettings AppSettings

<div class="row">
    <div class="col-md-4">
        <div class="card">
            <h5 class="card-header">@DataFormat Details</h5>
            <ul class="list-group list-group-flush">
                @if (DataFormat.ToLower() == "file")
                {
                    <li class="list-group-item"><span class="fw-bold">File name: </span>@Name</li>
                }
                <li class="list-group-item"><span class="fw-bold">Created: </span>@Created</li>
                <li class="list-group-item"><span class="fw-bold">Expires: </span>@Expiration</li>
                <li class="list-group-item"><span class="fw-bold">Size: </span>@Size bytes</li>
            </ul>
        </div>
    </div>
    <div class="col-md-8">
        <div class="card">
            <div class="card-body text-center">
                @if (decryptionSuccess == false)
                {
                    <h5 class="card-title">Decryption Key</h5>
                    <p class="card-text fst-italic">This should have been provided by the sender</p>
                    <div class="mb-3">
                        <input type="text" class="form-control" id="decryptionKey" @bind="decryptionKey">
                    </div>
                    <div class="mb-3">
                        <button type="button" class="btn btn-primary" @onclick="@(e => OnDecryptClicked(DataFormat, Id, decryptionKey))">Decrypt your @DataFormat</button>
                    </div>
                }
                else
                {
                    <div class="alert alert-success text-center" role="alert">
                        Decryption successful!
                    </div>
                    <div class="mb-3">
                        <textarea @bind="decryptedMessage" class="form-control" rows="5"></textarea>
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    private string decryptionKey = "";
    private bool decryptionSuccess = false;
    private string decryptedMessage = "";

    // Stores the Format received by parent component
    [Parameter] public string DataFormat { get; set; }

    // Stores the ID received by parent component
    [Parameter] public Guid Id { get; set; }

    // Stores the File name received by parent component
    [Parameter] public string Name { get; set; }

    // Stores the Creation Date received by parent component
    [Parameter] public string Created { get; set; }

    // Stores the Size received by parent component
    [Parameter] public int Size { get; set; }

    // Stores the Expiration Date received by parent component
    [Parameter] public string Expiration { get; set; }

    // Watch for changes in variable values in parent component to update here
    [Parameter] public EventCallback<string> DataFormatChanged { get; set; }
    [Parameter] public EventCallback<Guid> IdChanged { get; set; }
    [Parameter] public EventCallback<string> NameChanged { get; set; }
    [Parameter] public EventCallback<string> CreatedChanged { get; set; }
    [Parameter] public EventCallback<int> SizeChanged { get; set; }
    [Parameter] public EventCallback<string> ExpirationChanged { get; set; }

    private async Task OnDecryptClicked(string dataFormat, Guid id, string privateDecryptionKey)
    {
        // Convert the decryption key from Base64 => PEM formatted string => AsymmetricKeyParameter
        byte[] privateKeyPemBytes = Convert.FromBase64String(privateDecryptionKey);
        string privateKeyPemString = Encoding.UTF8.GetString(privateKeyPemBytes);
        var privateKeyBouncyCastle = ExtMethods.ConvertFromPEM(privateKeyPemString).Private;

        // Request the signature from the API
        var signatureResponse = await DownloadSignature(dataFormat, id);
        var signatureBytes = Convert.FromBase64String(signatureResponse.Signature);

        // Attempt to decrypt the signature
        var asymmetricWrapper = new AsymmetricWrapper();
        byte[] decryptedSignatureBytes = asymmetricWrapper.Decrypt(signatureBytes, privateKeyBouncyCastle);
        string decryptedSignatureString = Encoding.UTF8.GetString(decryptedSignatureBytes);

        // Attempt to deserialize the plaintext signature
        var signature = new AnonymousSignature(decryptedSignatureString);

        // Request the ciphertext from the server
        var serverDecryptionKey = DigestWrapper.GetDigest(Convert.FromBase64String(signature.Key), DigestAlgorithm.SHA256);
        var encodedServerDecryptionKey = Convert.ToBase64String(serverDecryptionKey);
        var ciphertextResponse = await DownloadCiphertext(DataFormat, id, encodedServerDecryptionKey);

        // Decrypt the ciphertext using the symmetric key from the signature
        byte[] plaintextBytes = DecryptCiphertext(ciphertextResponse.CipherText, signature.Key, signature.IV);

        var verifyResult = VerifyPlaintextAgainstKnownDigest(plaintextBytes, signature.Digest);
        if (verifyResult)
        {
            Console.WriteLine("Plaintext looks good!");
            decryptionSuccess = true;
        }
        else
        {
            Console.WriteLine("Plaintext is bad :(");
        }

        if (dataFormat == "message")
        {
            decryptedMessage = Encoding.UTF8.GetString(plaintextBytes);
            Console.WriteLine(Encoding.UTF8.GetString(plaintextBytes));
        }
        else
        {
            // Probably this: https://stackoverflow.com/a/53822526
        }

    }

    /// <summary>
    /// Request the signature from the API
    /// </summary>
    /// <param name="dataFormat">"file" or "message"</param>
    /// <param name="id">The guid corresponding to the resource</param>
    /// <returns></returns>
    private async Task<AnonymousSignatureResponse> DownloadSignature(string dataFormat, Guid id)
    {
        var url = $"{AppSettings.ApiBaseUrl}/{dataFormat}/signature/{id}";
        using var response = await HttpClient.GetAsync(url);

        if (!response.IsSuccessStatusCode)
        {
            // insert error handling
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousSignatureResponse>(content);
    }

    /// <summary>
    /// Request the ciphertext from the API
    /// </summary>
    /// <param name="dataFormat">"file" or "message"</param>
    /// <param name="id">The guid corresponding to the resource</param>
    /// <param name="serverDecryptionKey">Base64(Sha256(GetBytes(symmetricKey)))</param>
    /// <returns></returns>
    private async Task<AnonymousDownloadResponse> DownloadCiphertext(string dataFormat, Guid id, string serverDecryptionKey)
    {
        var fileRequestBody = new AnonymousFileDownloadRequest
        {
            Id = id,
            ServerDecryptionKey = serverDecryptionKey
        };

        var messageRequestBody = new AnonymousMessageDownloadRequest
        {
            Id = id,
            ServerDecryptionKey = serverDecryptionKey
        };

        var url = $"{AppSettings.ApiBaseUrl}/{dataFormat}/actual";

        using var response = dataFormat == "file"
            ? await HttpClient.PostAsJsonAsync(url, fileRequestBody)
            : await HttpClient.PostAsJsonAsync(url, messageRequestBody);

        if (!response.IsSuccessStatusCode)
        {
            // insert error handling
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousDownloadResponse>(content);
    }

    /// <summary>
    /// Decrypt the ciphertext received from the API using the provided key
    /// </summary>
    /// <param name="ciphertext">Base64 encoded ciphertext; raw from the API response</param>
    /// <param name="symmetricKey">Base64 encoded symmetric key; raw from the signature</param>
    /// <param name="iv">Base64 encoded IV; raw from the signature</param>
    /// <returns>Plaintext as bytes</returns>
    private byte[] DecryptCiphertext(string ciphertext, string symmetricKey, string iv)
    {
        var decodedCiphertext = Convert.FromBase64String(ciphertext);
        var decodedKey = Convert.FromBase64String(symmetricKey);
        var decodedIV = Convert.FromBase64String(iv);

        var symmetricParams = Common.MakeSymmetricCryptoParams(decodedKey, decodedIV);
        return Common.UndoSymmetricEncryption(decodedCiphertext, symmetricParams);
    }

    /// <summary>
    /// Digest the plaintext bytes and compare to the digest from the signature
    /// </summary>
    /// <param name="plaintext"></param>
    /// <param name="knownDigest">Base64 encoded digest; raw from the signature</param>
    /// <returns></returns>
    private bool VerifyPlaintextAgainstKnownDigest(byte[] plaintext, string knownDigest)
    {
        var decodedDigest = Convert.FromBase64String(knownDigest);
        var newDigest = DigestWrapper.GetDigest(plaintext, DigestAlgorithm.SHA256);

        if (decodedDigest.Length < (256 / 8))
        {
            return false;
        }

        for (int i = 0; i < (256 / 8); i++)
        {
            if (!decodedDigest[i].Equals(newDigest[i]))
            {
                return false;
            }
        }
        return true;
    }
}
