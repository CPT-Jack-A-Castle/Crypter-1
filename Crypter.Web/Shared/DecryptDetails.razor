@inject HttpClient HttpClient
@inject AppSettings AppSettings

<div class="decryption-details">
    <div class="details col-md-3">
        <h3>@DataFormat details</h3>
        <table class="data-details">
            @if (DataFormat.ToLower() == "file")
            {
                <tr>
                    <td><strong>File name: </strong></td>
                    <td>@Name</td>
                </tr>
            }
            <tr>
                <td><strong>Created: </strong></td>
                <td>@Created</td>
            </tr>
            <tr>
                <td><strong>Size: </strong></td>
                <td>@Size bytes</td>
            </tr>
            <tr>
                <td><strong>Expires at: </strong></td>
                <td>@Expiration</td>
            </tr>
        </table>
    </div>
    <div class="decryption-key col-md-9">
        <h4>Decryption Key</h4>
        <p><em>This should have been provided by the sender</em></p>
        <input @bind="decryptionKey" type="text" />
        <button type="button" class="btn btn-primary" @onclick="@(e => OnDecryptClicked(DataFormat, Id, decryptionKey))">Decrypt</button>
    </div>
</div>

@code {
    private string decryptionKey = "";

    // Stores the Format received by parent component
    [Parameter] public string DataFormat { get; set; }

    // Stores the ID received by parent component
    [Parameter] public Guid Id { get; set; }

    // Stores the File name received by parent component
    [Parameter] public string Name { get; set; }

    // Stores the Creation Date received by parent component
    [Parameter] public string Created { get; set; }

    // Stores the Size received by parent component
    [Parameter] public int Size { get; set; }

    // Stores the Expiration Date received by parent component
    [Parameter] public string Expiration { get; set; }

    // Watch for changes in variable values in parent component to update here
    [Parameter] public EventCallback<string> DataFormatChanged { get; set; }
    [Parameter] public EventCallback<Guid> IdChanged { get; set; }
    [Parameter] public EventCallback<string> NameChanged { get; set; }
    [Parameter] public EventCallback<string> CreatedChanged { get; set; }
    [Parameter] public EventCallback<int> SizeChanged { get; set; }
    [Parameter] public EventCallback<string> ExpirationChanged { get; set; }

    private async Task OnDecryptClicked(string dataFormat, Guid id, string privateDecryptionKey)
    {
        // Convert the decryption key from Base64 => PEM formatted string => AsymmetricKeyParameter
        byte[] privateKeyPemBytes = Convert.FromBase64String(privateDecryptionKey);
        string privateKeyPemString = Encoding.UTF8.GetString(privateKeyPemBytes);
        var privateKeyBouncyCastle = ExtMethods.ConvertFromPEM(privateKeyPemString).Private;

        // Request the signature from the API
        var signatureResponse = await DownloadSignature(dataFormat, id);
        var signatureBytes = Convert.FromBase64String(signatureResponse.Signature);

        // Attempt to decrypt the signature
        var asymmetricWrapper = new AsymmetricWrapper();
        byte[] decryptedSignatureBytes = asymmetricWrapper.Decrypt(signatureBytes, privateKeyBouncyCastle);
        string decryptedSignatureString = Encoding.UTF8.GetString(decryptedSignatureBytes);

        // Attempt to deserialize the plaintext signature
        var signature = new AnonymousSignature(decryptedSignatureString);

        // Request the ciphertext from the server
        var serverDecryptionKey = DigestWrapper.GetDigest(Convert.FromBase64String(signature.Key), DigestAlgorithm.SHA256);
        var encodedServerDecryptionKey = Convert.ToBase64String(serverDecryptionKey);
        var ciphertextResponse = await DownloadCiphertext(DataFormat, id, encodedServerDecryptionKey);

        // Decrypt the ciphertext using the symmetric key from the signature
        byte[] plaintextBytes = DecryptCiphertext(ciphertextResponse.CipherText, signature.Key, signature.IV);

        var verifyResult = VerifyPlaintextAgainstKnownDigest(plaintextBytes, signature.Digest);
        if (verifyResult)
        {
            Console.WriteLine("Plaintext looks good!");
        }
        else
        {
            Console.WriteLine("Plaintext is bad :(");
        }

        if (dataFormat == "message")
        {
            Console.WriteLine(Encoding.UTF8.GetString(plaintextBytes));
        }
        else
        {
            // Probably this: https://stackoverflow.com/a/53822526
        }

    }

    /// <summary>
    /// Request the signature from the API
    /// </summary>
    /// <param name="dataFormat">"file" or "message"</param>
    /// <param name="id">The guid corresponding to the resource</param>
    /// <returns></returns>
    private async Task<AnonymousSignatureResponse> DownloadSignature(string dataFormat, Guid id)
    {
        var url = $"{AppSettings.ApiBaseUrl}/{dataFormat}/signature/{id}";
        using var response = await HttpClient.GetAsync(url);

        if (!response.IsSuccessStatusCode)
        {
            // insert error handling
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousSignatureResponse>(content);
    }

    /// <summary>
    /// Request the ciphertext from the API
    /// </summary>
    /// <param name="dataFormat">"file" or "message"</param>
    /// <param name="id">The guid corresponding to the resource</param>
    /// <param name="serverDecryptionKey">Base64(Sha256(GetBytes(symmetricKey)))</param>
    /// <returns></returns>
    private async Task<AnonymousDownloadResponse> DownloadCiphertext(string dataFormat, Guid id, string serverDecryptionKey)
    {
        var fileRequestBody = new AnonymousFileDownloadRequest
        {
            Id = id,
            ServerDecryptionKey = serverDecryptionKey
        };

        var messageRequestBody = new AnonymousMessageDownloadRequest
        {
            Id = id,
            ServerDecryptionKey = serverDecryptionKey
        };

        var url = $"{AppSettings.ApiBaseUrl}/{dataFormat}/actual";

        using var response = dataFormat == "file"
            ? await HttpClient.PostAsJsonAsync(url, fileRequestBody)
            : await HttpClient.PostAsJsonAsync(url, messageRequestBody);

        if (!response.IsSuccessStatusCode)
        {
            // insert error handling
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousDownloadResponse>(content);
    }

    /// <summary>
    /// Decrypt the ciphertext received from the API using the provided key
    /// </summary>
    /// <param name="ciphertext">Base64 encoded ciphertext; raw from the API response</param>
    /// <param name="symmetricKey">Base64 encoded symmetric key; raw from the signature</param>
    /// <param name="iv">Base64 encoded IV; raw from the signature</param>
    /// <returns>Plaintext as bytes</returns>
    private byte[] DecryptCiphertext(string ciphertext, string symmetricKey, string iv)
    {
        var decodedCiphertext = Convert.FromBase64String(ciphertext);
        var decodedKey = Convert.FromBase64String(symmetricKey);
        var decodedIV = Convert.FromBase64String(iv);

        var symmetricParams = Common.MakeSymmetricCryptoParams(decodedKey, decodedIV);
        return Common.UndoSymmetricEncryption(decodedCiphertext, symmetricParams);
    }

    /// <summary>
    /// Digest the plaintext bytes and compare to the digest from the signature
    /// </summary>
    /// <param name="plaintext"></param>
    /// <param name="knownDigest">Base64 encoded digest; raw from the signature</param>
    /// <returns></returns>
    private bool VerifyPlaintextAgainstKnownDigest(byte[] plaintext, string knownDigest)
    {
        var decodedDigest = Convert.FromBase64String(knownDigest);
        var newDigest = DigestWrapper.GetDigest(plaintext, DigestAlgorithm.SHA256);

        if (decodedDigest.Length < (256 / 8))
        {
            return false;
        }

        for (int i = 0; i < (256 / 8); i++)
        {
            if (!decodedDigest[i].Equals(newDigest[i]))
            {
                return false;
            }
        }
        return true;
    }
}
