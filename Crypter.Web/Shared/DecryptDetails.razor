@inject HttpClient HttpClient
@inject AppSettings AppSettings
@inject IJSRuntime js

<div class="row">
    <div class="col-md-4">
        <div class="card">
            <h5 class="card-header">Details</h5>
            <ul class="list-group list-group-flush">
                @if (DataFormat.ToLower() == "file")
                {
                    <li class="list-group-item"><span class="fw-bold">File name: </span>@Name</li>
                    <li class="list-group-item"><span class="fw-bold">Type: </span>@ContentType</li>
                }
                <li class="list-group-item"><span class="fw-bold">Created: </span>@Created</li>
                <li class="list-group-item"><span class="fw-bold">Expires: </span>@Expiration</li>
                <li class="list-group-item"><span class="fw-bold">Size: </span>@Size bytes</li>
            </ul>
        </div>
    </div>
    <div class="col-md-8">
        <div class="card">
            <div class="card-body text-center">
                @if (decryptionSuccess == false)
                {
                    <h5 class="card-title">Decryption Key</h5>
                    <p class="card-text fst-italic">This should have been provided by the sender</p>
                    @if (decryptionError == true)
                    {
                        <div class="alert alert-danger text-center" role="alert">
                            @decryptionErrorText
                        </div>
                    }
                    @if (!IsDecrypting) {
                        <div class="mb-3">
                            <input type="text" class="form-control" id="decryptionKey" @bind="decryptionKey">
                        </div>
                        <div class="mb-3">
                            <button type="button" class="btn btn-primary" @onclick="@(e => OnDecryptClicked(DataFormat, Id, decryptionKey))">Decrypt your @DataFormat</button>
                        </div>
                    } else 
                    { 
                        <div class="mb-3">
                            <h3>@DecryptionStatusMessage</h3>
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    }
                }
                else
                {
                    <div class="alert alert-success text-center" role="alert">
                        Decryption successful!
                    </div>
                    @if (DataFormat == "message")
                    {
                        <div class="mb-3">
                            <textarea @bind="decryptedMessage" class="form-control" rows="5"></textarea>
                        </div>
                    }
                    else
                    {
                        <div class="mb-3">
                            <button type="button" class="btn btn-primary" @onclick="@(e => DownloadFile(Name, decryptedFile, ContentType))">Download your file</button>
                        </div>
                    }
                }
            </div>
        </div>
    </div>
</div>

@code {

    // State
    private bool IsDecrypting = false;
    private string DecryptionStatusMessage = "";

    private string decryptionKey = "";
    private bool decryptionSuccess = false;
    private bool decryptionError = false;
    private string decryptionErrorText = "";
    private string decryptedMessage = "";
    private byte[] decryptedFile;

    [Inject] public IBlazorDownloadFileService BlazorDownloadFileService { get; set; }

    // Stores the Format received by parent component
    [Parameter] public string DataFormat { get; set; }

    // Stores the ID received by parent component
    [Parameter] public Guid Id { get; set; }

    // Stores the File name received by parent component
    [Parameter] public string Name { get; set; }

    // Stores the Creation Date received by parent component
    [Parameter] public string Created { get; set; }

    // Stores the Size received by parent component
    [Parameter] public int Size { get; set; }

    // Stores the Expiration Date received by parent component
    [Parameter] public string Expiration { get; set; }

    // Store the Content Type received by parent component
    [Parameter] public string ContentType { get; set; }

    // Watch for changes in variable values in parent component to update here
    [Parameter] public EventCallback<string> DataFormatChanged { get; set; }
    [Parameter] public EventCallback<Guid> IdChanged { get; set; }
    [Parameter] public EventCallback<string> NameChanged { get; set; }
    [Parameter] public EventCallback<string> CreatedChanged { get; set; }
    [Parameter] public EventCallback<int> SizeChanged { get; set; }
    [Parameter] public EventCallback<string> ExpirationChanged { get; set; }
    [Parameter] public EventCallback<string> ContentTypeChanged { get; set; }

    private async Task OnDecryptClicked(string dataFormat, Guid id, string privateDecryptionKey)
    {
        IsDecrypting = true;
        decryptionError = false;

        // Attempt to convert the decryption key from Base64
        await SetNewDecryptionStatus("Decoding key");
        string pemKey;
        try
        {
            byte[] pemKeyAsBytes = Convert.FromBase64String(privateDecryptionKey);
            pemKey = Encoding.UTF8.GetString(pemKeyAsBytes);
        }
        catch (FormatException)
        {
            decryptionError = true;
            IsDecrypting = false;
            decryptionErrorText = "Invalid key format";
            return;
        }

        ResourceType resourceType = DataFormat.ToLower() == "message"
            ? ResourceType.Message
            : ResourceType.File;

        // Request the signature from the API
        await SetNewDecryptionStatus("Downloading signature");
        var signatureResponse = await DownloadSignature(resourceType, id);
        byte[] encryptedSignature = Convert.FromBase64String(signatureResponse.Signature);

        // Attempt to decrypt the signature using the provided key
        await SetNewDecryptionStatus("Decrypting signature");
        AnonymousSignature signature;
        try
        {
            signature = CryptoLib.Common.DecryptAndDeserializeSignature(encryptedSignature, pemKey);
        }
        catch (FormatException)
        {
            decryptionError = true;
            IsDecrypting = false;
            decryptionErrorText = "Failed to decrypt signature";
            return;
        }

        // Request the ciphertext from the server
        await SetNewDecryptionStatus($"Downloading {dataFormat}");
        var serverDecryptionKey = CryptoLib.Common.GetDigest(signature.Key, DigestAlgorithm.SHA256);
        var encodedServerDecryptionKey = Convert.ToBase64String(serverDecryptionKey);
        var ciphertextResponse = await DownloadCiphertext(resourceType, id, encodedServerDecryptionKey);

        if (ciphertextResponse.Status.Equals(Contracts.Enum.ResponseCode.DecryptFailure))
        {
            decryptionError = true;
            IsDecrypting = false;
            decryptionErrorText = "Failed to remove server-side encryption";
            return;
        }

        // Decrypt the ciphertext using the symmetric key from the signature
        await SetNewDecryptionStatus($"Decrypting {dataFormat}");
        byte[] ciphertextBytes = Convert.FromBase64String(ciphertextResponse.CipherText);
        var symmetricParams = CryptoLib.Common.MakeSymmetricCryptoParams(signature.Key, signature.IV);
        byte[] plaintextBytes = CryptoLib.Common.UndoSymmetricEncryption(ciphertextBytes, symmetricParams);

        await SetNewDecryptionStatus($"Verifying decrypted {dataFormat}");
        decryptionSuccess = CryptoLib.Common.VerifyPlaintextAgainstKnownDigest(plaintextBytes, signature.Digest);

        if (decryptionSuccess)
        {
            if (dataFormat == "message")
            {
                decryptedMessage = Encoding.UTF8.GetString(plaintextBytes);
            }
            else
            {
                decryptedFile = plaintextBytes;
            }
        }
        else
        {
            decryptionError = true;
            IsDecrypting = false;
            decryptionErrorText = $"Failed to verify decrypted {dataFormat.ToLower()}";
            return;
        }
    }

    /// <summary>
    /// Request the signature from the API
    /// </summary>
    /// <param name="dataFormat">"file" or "message"</param>
    /// <param name="id">The guid corresponding to the resource</param>
    /// <returns></returns>
    private async Task<AnonymousSignatureResponse> DownloadSignature(ResourceType type, Guid id)
    {
        var url = $"{AppSettings.ApiBaseUrl}/anonymous/get-signature";
        var requestBody = new AnonymousSignatureRequest(id, type);
        using var response = await HttpClient.PostAsJsonAsync(url, requestBody);

        if (!response.IsSuccessStatusCode)
        {
            decryptionError = true;
            decryptionErrorText = "Error: Failed to decrypt signature";
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousSignatureResponse>(content);
    }

    /// <summary>
    /// Request the ciphertext from
    /// </summary>
    /// <param name="dataFormat">"file" or "message"</param>
    /// <param name="id">The guid corresponding to the resource</param>
    /// <param name="serverDecryptionKey">Base64(Sha256(GetBytes(symmetricKey)))</param>
    /// <returns></returns>
    private async Task<AnonymousDownloadResponse> DownloadCiphertext(ResourceType type, Guid id, string serverDecryptionKey)
    {
        var requestBody = new AnonymousDownloadRequest(id, type, serverDecryptionKey);

        var url = $"{AppSettings.ApiBaseUrl}/anonymous/get-item";

        var response = await HttpClient.PostAsJsonAsync(url, requestBody);

        if (!response.IsSuccessStatusCode)
        {
            decryptionError = true;
            decryptionErrorText = $"Error: Unable to decrypt {type.ToString().ToLower()}";
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousDownloadResponse>(content);
    }

    private async Task DownloadFile(string fileName, byte[] fileContent, string contentType)
    {
        await BlazorDownloadFileService.DownloadFileAsync(fileName, fileContent, contentType);
    }

    public async Task SetNewDecryptionStatus(string status)
    {
        DecryptionStatusMessage = status;
        StateHasChanged();
        await Task.Delay(500);
    }
}
