@using BlazorInputFile

@inject IJSRuntime jsRuntime
@inject IAuthenticationService AuthenticationService
@inject IUploadService UploadService

<div class="file-upload" hidden="@IsEncrypting">
   <div class="row">
      <div class="col-12 p-0">
         <div class="card dropzone @dropClass rounded mb-3">
            <p class="card-text dz-text">
               <i class="bi bi-file-arrow-up d-block fs-1 my-3"></i>
               <span class="fw-bold">Choose a file</span> or drag it here to upload
            </p>
            <BlazorInputFile.InputFile id="fileInput"
                                       OnChange="HandleFileInputChange"
                                       @ondragenter="HandleDragEnter"
                                       @ondragleave="HandleDragLeave" />
         </div>
         @if (Error)
         {
            foreach (var errorMessage in ErrorMessages)
            {
               <div class="validation-errors my-3">
                  <div class="alert alert-danger" role="alert">
                     @errorMessage
                  </div>
               </div>
            }
         }
         @if (selectedFiles != null && selectedFiles.Count > 0)
         {
            <div class="card my-3">
               <div class="card-body">
                  @selectedFiles[0].Name
                  <button type="button" class="btn-close float-end" aria-label="Remove file" @onclick="@(e => RemoveFile(selectedFiles[0]))"></button>
               </div>
            </div>
         }
      </div>
   </div>
   <div class="row">
      <div class="col-12 p-0">
         <button type="button" class="btn btn-primary mx-auto d-block" @onclick="@(e => OnEncryptFileClicked(selectedFiles, encryptionStrength))">Encrypt</button>
      </div>
   </div>
   <UploadSuccessModal @ref="Modal" @bind-DataFormat="dataFormat" @bind-ReturnedId="returnedId" @bind-PrivateKey="privateKey" />
   <UploadSuccessModalWithRecipient @ref="ModalForRecipient" />
</div>

<div class="encrypt-status" hidden="@(!IsEncrypting)">
   <h3>@EncryptionStatusMessage</h3>
   <div class="spinner-border" role="status">
      <span class="visually-hidden">Loading...</span>
   </div>
</div>

@code {
   [Parameter]
   public string RecipientUsername { get; set; }

   [Parameter]
   public string RecipientPublicKey { get; set; }

   // Constants
   private const int MaxFileSizeMB = 10;
   private const int MaxFileSize = MaxFileSizeMB * 1024 * 1024;
   private const int MaxFileCount = 1;

   // State
   private bool IsEncrypting = false;
   private string EncryptionStatusMessage = "";

   // User input
   private List<IFileListEntry> selectedFiles = new List<IFileListEntry>();
   private CryptoStrength encryptionStrength = CryptoStrength.Minimum;

   // Variables we control
   private string dropClass = "";
   private bool Error;
   private List<string> ErrorMessages;
   private Guid returnedId;
   private string privateKey;
   private string dataFormat;

   // Generated keys and crypto params
   private WrapsAsymmetricCipherKeyPair asymmetricKeyPair;
   private SymmetricCryptoParams symmetricParams;
   private byte[] serverEncryptionKey;

   private void HandleDragEnter()
   {
      dropClass = "dropzone-drag";
   }

   private void HandleDragLeave()
   {
      dropClass = "";
   }

   private void HandleFileInputChange(IFileListEntry[] files)
   {
      dropClass = "";
      Error = false;
      ErrorMessages = new List<string>();

      if (files != null)
      {
         if (files.Count() == 0)
         {
            Error = true;
            ErrorMessages.Append("No file selected.");
            return;
         }

         if (files.Count() > MaxFileCount)
         {
            Error = true;
            ErrorMessages.Append($"You can only upload {MaxFileCount} file(s) at a time.");
            return;
         }

         if (files[0].Size > MaxFileSize)
         {
            Error = true;
            ErrorMessages.Append($"The max file size is {MaxFileSizeMB} MB.");
            return;
         }

         selectedFiles.Add(files[0]);
      }
   }

   private void RemoveFile(IFileListEntry file)
   {
      selectedFiles.Remove(file);
   }

   private async Task OnEncryptFileClicked(List<IFileListEntry> files, CryptoStrength strength)
   {
      if (files.Count == 1)
      {
         IsEncrypting = true;
         await GenerateKeys(strength);
         GC.Collect();
         await Task.Delay(500);
         await EncryptFile(files[0], strength);
         GC.Collect();
         ClearKeys();
         GC.Collect();
      }
   }

   private async Task GenerateKeys(CryptoStrength strength)
   {
      await SetNewEncryptionStatus("Creating symmetric key");
      symmetricParams = CryptoLib.Common.GenerateSymmetricCryptoParams(strength);
      serverEncryptionKey = CryptoLib.Common.GetDigest(symmetricParams.Key.ConvertToBytes(), DigestAlgorithm.SHA256);

      await SetNewEncryptionStatus("Creating asymmetric keys. This may take a while.");
      asymmetricKeyPair = CryptoLib.Common.GenerateAsymmetricKeys(strength);
   }

   private void ClearKeys()
   {
      asymmetricKeyPair = null;
      symmetricParams = null;
      serverEncryptionKey = null;
   }

   private async Task EncryptFile(IFileListEntry file, CryptoStrength strength)
   {
      await SetNewEncryptionStatus("Encrypting your file");
      using var stream = new MemoryStream();
      await file.Data.CopyToAsync(stream);
      byte[] fileBytes = stream.ToArray();
      var cipherText = CryptoLib.Common.DoSymmetricEncryption(fileBytes, symmetricParams);

      await SetNewEncryptionStatus("Encrypting symmetric key");
      var publicKeyToEncryptWith = string.IsNullOrEmpty(RecipientUsername)
          ? asymmetricKeyPair.Public
          : CryptoLib.Common.ConvertRsaPublicKeyFromPEM(RecipientPublicKey);

      var encryptedSymmetricInfo = CryptoLib.Common.EncryptSymmetricInfo(symmetricParams, publicKeyToEncryptWith);

      await SetNewEncryptionStatus("Creating a signature");
      var signature = CryptoLib.Common.SignPlaintext(fileBytes, asymmetricKeyPair.Private);

      await SetNewEncryptionStatus("Preparing to upload");
      var encodedCipherText = Convert.ToBase64String(cipherText);
      var encodedSymmetricInfo = Convert.ToBase64String(encryptedSymmetricInfo);
      var encodedServerEncryptionKey = Convert.ToBase64String(serverEncryptionKey);
      var encodedSignature = Convert.ToBase64String(signature);
      var encodedPublicKey = Convert.ToBase64String(
          Encoding.UTF8.GetBytes(asymmetricKeyPair.Public.ConvertToPEM()));

      await SetNewEncryptionStatus("Uploading");
      var withAuth = AuthenticationService.User is not null;
      var request = new FileUploadRequest(file.Name, file.Type, encodedCipherText, encodedSymmetricInfo, encodedSignature, encodedServerEncryptionKey, encodedPublicKey, RecipientUsername);
      var (_, response) = await UploadService.UploadFileAsync(request, withAuth);

      switch (response.Result)
      {
         case UploadResult.BlockedByUserPrivacy:
            Error = true;
            ErrorMessages.Append("This user does not accept files.");
            IsEncrypting = false;
            return;
         case UploadResult.OutOfSpace:
            Error = true;
            ErrorMessages.Append("The server is full.  Try again later.");
            IsEncrypting = false;
            return;
         default:
            break;
      }

      CompletedUpload(response.Id, Convert.ToBase64String(Encoding.UTF8.GetBytes(asymmetricKeyPair.Private.ConvertToPEM())));

      if (string.IsNullOrEmpty(RecipientUsername))
      {
         Modal.Open();
      }
      else
      {
         ModalForRecipient.Open();
      }

      RemoveFile(selectedFiles[0]);
      IsEncrypting = false;
   }

   public async Task SetNewEncryptionStatus(string status)
   {
      EncryptionStatusMessage = status;
      StateHasChanged();
      await Task.Delay(500);
   }

   public void CompletedUpload(Guid id, string privKey)
   {
      dataFormat = "file";
      returnedId = id;
      privateKey = privKey;
   }

   private Crypter.Web.Shared.Modal.UploadSuccessModal Modal { get; set; }
   private Crypter.Web.Shared.Modal.UploadSuccessModalWithRecipient ModalForRecipient { get; set; }

   [Parameter]
   public EventCallback<string> RecipientUsernameChanged { get; set; }

   [Parameter]
   public EventCallback<string> RecipientPublicKeyChanged { get; set; }
}
