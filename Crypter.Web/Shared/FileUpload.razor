@using BlazorInputFile

@inject IJSRuntime jsRuntime
@inject HttpClient HttpClient

<div class="file-upload" hidden="@IsEncrypting">
   <div class="row">
      <div class="col-12 p-0">
         <div class="dropzone @dropClass rounded">
            <div class="dz-text">
               <p>Drop file here</p>
               <p>or</p>
            </div>
            <BlazorInputFile.InputFile id="fileInput"
                                       OnChange="HandleFileInputChange"
                                       @ondragenter="HandleDragEnter"
                                       @ondragleave="HandleDragLeave" />
         </div>
         @if ((fileSizeError || fileCountError))
         {
            <ul class="validation-errors mb-0">
               @if (fileSizeError)
               {
                  <li class="validation-message">The max file size is @MaxFileSizeMB MB.</li>
               }

               @if (fileCountError)
               {
                  <li class="validation-message">You can only upload @MaxFileCount file(s).</li>
               }
            </ul>
         }
         @if (selectedFiles != null && selectedFiles.Count > 0)
         {
            <div class="col-12">
               <ul>
                  @foreach (var file in selectedFiles)
                  {
                     <li>
                        @file.Name
                        <button class="btn btn-link text-danger p-0 pl-1" type="button"
                                @onclick="@(e => RemoveFile(file))">
                           <small class="align-text-bottom">Remove</small>
                        </button>
                     </li>
                  }
               </ul>
            </div>
         }
      </div>
   </div>
   <div class="row">
      <div class="col-12 p-0">
         <button type="button" class="btn btn-primary" @onclick="@(e => EncryptFile(selectedFiles[0], encryptionStrength))">Encrypt</button>
      </div>
   </div>
   <UploadSuccessModal @ref="Modal" @bind-DataFormat="dataFormat" @bind-ReturnedId="returnedId" @bind-PublicKey="publicKey" @bind-PrivateKey="privateKey" />
</div>

<h3 hidden="@(!IsEncrypting)">Encryption Processing</h3>

@code {
   // Constants
   private const int MaxFileSizeMB = 10;
   private const int MaxFileSize = MaxFileSizeMB * 1024 * 1024;
   private const int MaxFileCount = 1;

   // User input
   private List<IFileListEntry> selectedFiles = new List<IFileListEntry>();
   private CryptoStrength encryptionStrength = CryptoStrength.Minimum; //TODO Allow the user to set this in the UI

   // Variables we control
   private string dropClass = "";
   private bool fileSizeError = false;
   private bool fileCountError = false;
   private bool IsEncrypting = false;
   private Guid returnedId;
   private string publicKey;
   private string privateKey;
   private string dataFormat;

   private void HandleDragEnter()
   {
      dropClass = "dropzone-drag";
   }

   private void HandleDragLeave()
   {
      dropClass = "";
   }

   private void HandleFileInputChange(IFileListEntry[] files)
   {
      dropClass = "";
      fileSizeError = false;
      fileCountError = false;

      if (files != null)
      {
         foreach (var file in files)
         {
            bool error = false;
            if (file.Size > MaxFileSize)
            {
                error = true;
                fileSizeError = true;
            }

            if (selectedFiles.Count == MaxFileCount)
            {

                error = true;
                fileCountError = true;
            }

            if (!error)
            {
               selectedFiles.Add(file);
            }
         }
      }
   }

   private void RemoveFile(IFileListEntry file)
   {
      selectedFiles.Remove(file);
      fileCountError = false;
   }

   private async Task EncryptFile(IFileListEntry file, CryptoStrength strength)
   {
      // Hide file upload on encryption
      IsEncrypting = true;

      // Refer to https://stackoverflow.com/a/11701301 for procedure

      byte[] fileBytes = new byte[file.Data.Length];
      await file.Data.ReadAsync(fileBytes, 0, (int)file.Data.Length);
      var clientEncryptResult = CryptoLib.Common.DoAnonymousClientEncryption(fileBytes, strength);

      // Send POST request to API with upload details
      var response = await UploadFileToAPI(file.Name, clientEncryptResult.CipherText, clientEncryptResult.Signature, clientEncryptResult.ServerEncryptionKey);

      // Send data to success modal component
      CompletedUpload(response.Id, clientEncryptResult.KeyPair.Public.ConvertToPEM(), clientEncryptResult.KeyPair.Private.ConvertToPEM());

      // Open modal
      Modal.Open();

      // Reset File Uploads
      RemoveFile(selectedFiles[0]);

      // Show file upload after encryption
      IsEncrypting = false;
   }

   public void CompletedUpload(Guid id, string pubKey, string privKey)
   {
      dataFormat = format;
      returnedId = id;
      publicKey = pubKey;
      privateKey = privKey;
   }

   private async Task<AnonymousUploadResponse> UploadFileToAPI(string filename, string cipherText, string signature, string serverEncryptionKey)
   {
      var requestBody = new AnonymousFileUploadRequest
      {
         Name = filename,
         CipherText = cipherText,
         Signature = signature,
         ServerEncryptionKey = serverEncryptionKey
      };

      using var response = await HttpClient.PostAsJsonAsync("https://localhost:5001/api/file", requestBody);

      if (!response.IsSuccessStatusCode)
      {
         // insert error handling
      }

      var content = await response.Content.ReadAsStringAsync();
      return JsonConvert.DeserializeObject<AnonymousUploadResponse>(content);
   }

   private Crypter.Web.Shared.UploadSuccessModal Modal { get; set; }
}
