@using BlazorInputFile

@inject IJSRuntime jsRuntime
@inject HttpClient HttpClient
@inject AppSettings AppSettings
@inject IAuthenticationService AuthenticationService

<div class="file-upload" hidden="@IsEncrypting">
    <div class="row">
        <div class="col-12 p-0">
            <div class="card dropzone @dropClass rounded mb-3">
                <p class="card-text dz-text">
                    <i class="bi bi-file-arrow-up d-block fs-1 my-3"></i>
                    <span class="fw-bold">Choose a file</span> or drag it here to upload
                </p>
                <InputFile id="fileInput"
                           OnChange="HandleFileInputChange"
                           @ondragenter="HandleDragEnter"
                           @ondragleave="HandleDragLeave" />
            </div>
            @if ((fileSizeError || fileCountError || noFileSelected || serverIsFull))
            {
                <div class="validation-errors my-3">
                    @if (fileSizeError)
                    {
                        <div class="alert alert-danger" role="alert">
                            The max file size is @MaxFileSizeMB MB.
                        </div>
                    }

                    @if (fileCountError)
                    {
                        <div class="alert alert-danger" role="alert">
                            You can only upload @MaxFileCount file(s).
                        </div>
                    }

                    @if (noFileSelected)
                    {
                        <div class="alert alert-danger" role="alert">
                            No file selected.
                        </div>
                    }

                    @if (serverIsFull)
                    {
                        <div class="alert alert-danger" role="alert">
                            The server is full. Try again later.
                        </div>
                    }
                </div>
            }
            @if (selectedFiles != null && selectedFiles.Count > 0)
            {
                <div class="card my-3">
                    <div class="card-body">
                        @selectedFiles[0].Name
                        <button type="button" class="btn-close float-end" aria-label="Remove file" @onclick="@(e => RemoveFile(selectedFiles[0]))"></button>
                    </div>
                </div>
            }
        </div>
    </div>
    <div class="row">
        <div class="col-12 p-0">
            <button type="button" class="btn btn-primary mx-auto d-block" @onclick="@(e => OnEncryptFileClicked(selectedFiles, encryptionStrength))">Encrypt</button>
        </div>
    </div>
    <UploadSuccessModal @ref="Modal" @bind-DataFormat="dataFormat" @bind-ReturnedId="returnedId" @bind-PublicKey="publicKey" @bind-PrivateKey="privateKey" />
</div>

<div class="encrypt-status" hidden="@(!IsEncrypting)">
    <h3>@EncryptionStatusMessage</h3>
    <div class="spinner-border" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
</div>

@code {
    // Constants
    private const int MaxFileSizeMB = 10;
    private const int MaxFileSize = MaxFileSizeMB * 1024 * 1024;
    private const int MaxFileCount = 1;

    // State
    private bool IsEncrypting = false;
    private string EncryptionStatusMessage = "";

    // User input
    private List<IFileListEntry> selectedFiles = new List<IFileListEntry>();
    private CryptoStrength encryptionStrength = CryptoStrength.Minimum;

    // Variables we control
    private string dropClass = "";
    private bool fileSizeError = false;
    private bool fileCountError = false;
    private bool noFileSelected = false;
    private bool serverIsFull = false;
    private Guid returnedId;
    private string publicKey;
    private string privateKey;
    private string dataFormat;

    // Generated keys and crypto params
    private WrapsAsymmetricCipherKeyPair asymmetricKeyPair;
    private SymmetricCryptoParams symmetricParams;
    private byte[] serverEncryptionKey;

    private void HandleDragEnter()
    {
        dropClass = "dropzone-drag";
    }

    private void HandleDragLeave()
    {
        dropClass = "";
    }

    private void HandleFileInputChange(IFileListEntry[] files)
    {
        dropClass = "";
        fileSizeError = false;
        fileCountError = false;

        if (files != null)
        {
            foreach (var file in files)
            {
                bool error = false;
                if (file.Size > MaxFileSize)
                {
                    error = true;
                    fileSizeError = true;
                }

                if (selectedFiles.Count == MaxFileCount)
                {

                    error = true;
                    fileCountError = true;
                }

                if (!error)
                {
                    noFileSelected = false;
                    selectedFiles.Add(file);
                }
            }
        }
    }

    private void RemoveFile(IFileListEntry file)
    {
        selectedFiles.Remove(file);
        fileCountError = false;
    }

    private async Task OnEncryptFileClicked(List<IFileListEntry> files, CryptoStrength strength)
    {
        noFileSelected = files.Count == 0;
        if (!noFileSelected)
        {
            IsEncrypting = true;
            await GenerateKeys(strength);
            GC.Collect();
            await EncryptFile(files[0], strength);
            GC.Collect();
            ClearKeys();
            GC.Collect();
        }
    }

    private async Task GenerateKeys(CryptoStrength strength)
    {
        await SetNewEncryptionStatus("Creating symmetric key");
        symmetricParams = CryptoLib.Common.GenerateSymmetricCryptoParams(strength);
        serverEncryptionKey = CryptoLib.Common.GetDigest(symmetricParams.Key.ConvertToBytes(), DigestAlgorithm.SHA256);

        await SetNewEncryptionStatus("Creating asymmetric keys. This may take a while.");
        asymmetricKeyPair = CryptoLib.Common.GenerateAsymmetricKeys(strength);
    }

    private void ClearKeys()
    {
        asymmetricKeyPair = null;
        symmetricParams = null;
        serverEncryptionKey = null;
    }

    private async Task EncryptFile(IFileListEntry file, CryptoStrength strength)
    {
        await SetNewEncryptionStatus("Encrypting your file");
        using var stream = new MemoryStream();
        await file.Data.CopyToAsync(stream);
        byte[] fileBytes = stream.ToArray();
        var cipherText = CryptoLib.Common.DoSymmetricEncryption(fileBytes, symmetricParams);

        await SetNewEncryptionStatus("Encrypting symmetric key");
        var encryptedSymmetricInfo = CryptoLib.Common.EncryptSymmetricInfo(symmetricParams, asymmetricKeyPair.Public);

        await SetNewEncryptionStatus("Creating a signature");
        var signature = CryptoLib.Common.SignPlaintext(fileBytes, asymmetricKeyPair.Private);

        await SetNewEncryptionStatus("Preparing to upload");
        var encodedCipherText = Convert.ToBase64String(cipherText);
        var encodedSymmetricInfo = Convert.ToBase64String(encryptedSymmetricInfo);
        var encodedServerEncryptionKey = Convert.ToBase64String(serverEncryptionKey);
        var encodedSignature = Convert.ToBase64String(signature);
        var encodedPublicKey = Convert.ToBase64String(
            Encoding.UTF8.GetBytes(asymmetricKeyPair.Public.ConvertToPEM()));

        await SetNewEncryptionStatus("Uploading");
        if (AuthenticationService.User == null)
        {
            var response = await UploadFileToAPI(file.Name, file.Type, encodedCipherText, encodedSymmetricInfo, encodedSignature, encodedServerEncryptionKey, encodedPublicKey);

            if (response.Status.Equals(Contracts.Enum.ResponseCode.DiskFull))
            {
                serverIsFull = true;
                IsEncrypting = false;
                return;
            }

            // Send data to success modal component
            CompletedUpload("file", response.Id,
               Convert.ToBase64String(Encoding.UTF8.GetBytes(asymmetricKeyPair.Public.ConvertToPEM())),
               Convert.ToBase64String(Encoding.UTF8.GetBytes(asymmetricKeyPair.Private.ConvertToPEM())));
        }
        else
        {
            // TODO - Need to sign with the user's private key; not the generated private key
            var response = await UploadUserFileToAPI(file.Name, file.Type, encodedCipherText, encodedSymmetricInfo, encodedSignature, encodedServerEncryptionKey, encodedPublicKey);

            if (response.Status.Equals(Contracts.Enum.ResponseCode.DiskFull))
            {
                serverIsFull = true;
                IsEncrypting = false;
                return;
            }

            // Send data to success modal component
            CompletedUpload("file", response.Id,
               Convert.ToBase64String(Encoding.UTF8.GetBytes(asymmetricKeyPair.Public.ConvertToPEM())),
               Convert.ToBase64String(Encoding.UTF8.GetBytes(asymmetricKeyPair.Private.ConvertToPEM())));
        }

        // Open modal
        Modal.Open();

        // Reset File Uploads
        RemoveFile(selectedFiles[0]);

        // Show file upload after encryption
        IsEncrypting = false;
    }

    public async Task SetNewEncryptionStatus(string status)
    {
        EncryptionStatusMessage = status;
        StateHasChanged();
        await Task.Delay(500);
    }

    public void CompletedUpload(string format, Guid id, string pubKey, string privKey)
    {
        dataFormat = format;
        returnedId = id;
        publicKey = pubKey;
        privateKey = privKey;
    }

    private async Task<AnonymousUploadResponse> UploadFileToAPI(string filename, string contentType, string cipherText, string encryptedSymmetricInfo, string signature, string serverEncryptionKey, string publicKey)
    {
        var requestBody = new AnonymousUploadRequest(filename, ResourceType.File, contentType, cipherText, encryptedSymmetricInfo, signature, serverEncryptionKey, publicKey);

        using var response = await HttpClient.PostAsJsonAsync($"{AppSettings.ApiBaseUrl}/anonymous/upload", requestBody);

        if (!response.IsSuccessStatusCode)
        {
            // insert error handling
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<AnonymousUploadResponse>(content);
    }

    private async Task<RegisteredUserUploadResponse> UploadUserFileToAPI(string filename, string contentType, string cipherText, string encryptedSymmetricInfo, string signature, string serverEncryptionKey, string publicKey)
    {
        var url = $"{AppSettings.ApiBaseUrl}/user/upload";
        var token = AuthenticationService.User.Token;

        var request = new HttpRequestMessage(HttpMethod.Post, url);
        var postBody = new RegisteredUserUploadRequest(filename, ResourceType.File, contentType, cipherText, encryptedSymmetricInfo, signature, serverEncryptionKey, publicKey);

        request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);
        request.Content = JsonContent.Create(postBody);

        using var response = await HttpClient.SendAsync(request);

        if (!response.IsSuccessStatusCode)
        {
            // insert error handling
        }

        var content = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<RegisteredUserUploadResponse>(content);
    }

    private Crypter.Web.Shared.UploadSuccessModal Modal { get; set; }
}
